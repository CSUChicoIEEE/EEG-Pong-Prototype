"""
=========
WSHandler
=========

WebSockets are not standard HTTP connections. The "handshake" is HTTP,
but after the handshake, the protocol is message-based.

This implementation suppose that input message are in JSON format, each input
message will trigger a response message (in JSON format too) with a ``debug``
information.
"""

from io import StringIO

import json

from tornado.ioloop import IOLoop
from tornado import websocket
from datetime import timedelta

import traceback

import logging


from openbci import acquisition
from openbci.database import load_sample_8ch_bin


########################################################################
class WSHandler(websocket.WebSocketHandler):
    """Websocket handler."""

    CLIENTS = []
    STREAMING = False
    device = None
    # device = acquisition.CythonWiFi('192.168.4.1')
    # device = acquisition.CythonWiFi('192.168.0.30')
    device = acquisition.CytonRFDuino()
    # device.leadoff_impedance([0, 1, 2, 3, 4, 5, 6, 7], device.TEST_SIGNAL_NOT_APPLIED, device.TEST_SIGNAL_NOT_APPLIED)
    # device.leadoff_impedance([0, 1, 2, 3, 4, 5, 6, 7], device.TEST_SIGNAL_APPLIED, device.TEST_SIGNAL_NOT_APPLIED)
    # device.leadoff_impedance([0, 1, 2, 3, 4, 5, 6, 7], device.TEST_SIGNAL_APPLIED, device.TEST_SIGNAL_APPLIED)
    # device.leadoff_impedance([0, 1, 2, 3, 4, 5, 6, 7], device.TEST_SIGNAL_NOT_APPLIED, device.TEST_SIGNAL_APPLIED)
    # device.leadoff_impedance([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], device.TEST_SIGNAL_NOT_APPLIED, device.TEST_SIGNAL_APPLIED)
    PACK_ID = 0

    # ----------------------------------------------------------------------

    def initialize(self, device_config):
        """Load config values from main app.

        Parameters
        ----------
        device_config: dict
            Dictionary from frame.
        """

        # mod = getattr(acquisition, device_config['module'])

        # if 'ip_address' in device_config:
            # device = mod(device_config['ip_address'])
        # else:
            # device = mod()

        self.device_config = device_config

    # ----------------------------------------------------------------------

    def check_origin(self, origin):
        """Prevents a WebSocket from being used by another website that the user is also visiting."""

        return True

    # ----------------------------------------------------------------------
    def open(self, *args, **kwargs):
        #global STREAMING, CLIENTS
        """Return a message to client for confirm connection."""

        #IOLoop.instance().add_timeout(timedelta(seconds=1), self.send_data, {'type': 'LOG', 'message': 'CONNECTED', })
        logging.warning(f'Adding client {self}')
        self.CLIENTS.append(self)

    # ----------------------------------------------------------------------

    def on_close(self):
        #global STREAMING, CLIENTS
        """Stop IOLoop and debug connection."""

        # # IOLoop.instance().stop()
        if self in self.CLIENTS:
            self.CLIENTS.pop(self.CLIENTS.index(self))
        logging.info(f"Removing client {self}")

    # ----------------------------------------------------------------------
    def on_message(self, message):
        #global STREAMING, CLIENTS
        """Process input message.

        Parameters
        ----------
        message: dict
            Dictionary with 'command' key as python method.
        """

        request = json.loads(message)

        if not request.get('command', False):
            self.send_data({'type': 'ERROR', 'message': 'No argument "command" in this request.', }, request)
            return

        command = request.get('command')
        kwargs = request.get('kwargs')
        # args = request.get('args')

        if getattr(self.device, command, False):  # command is a method
            try:
                logging.info("Running command: \"{}\"".format(command))
                getattr(self.device, command)(**kwargs)  # call method
                self.send_data({'sample_rate': self.device.sample_rate, }, request)
            except AttributeError as e:
                t = {}
                t['message'] = str(e)
                t['traceback'] = traceback.format_exc()
                self.send_data({'type': 'ERROR', 'message': t, }, request)

        elif getattr(self, command, False):  # command is a method
            try:
                logging.info("Running command: \"{}\"".format(command))
                getattr(self, command)(**kwargs)  # call method
            except AttributeError as e:
                t = {}
                t['message'] = str(e)
                t['traceback'] = traceback.format_exc()
                self.send_data({'type': 'ERROR', 'message': t, }, request)
        else:
            self.send_data({'type': 'ERROR', 'message': 'No argument "command" in this request.', }, request)

    # ----------------------------------------------------------------------
    @classmethod
    def send_data(self, data, request={}):
        #global STREAMING, CLIENTS
        """Return data to client.

        Parameters
        ----------
        data: dict
            Dictionary with desired data to return.
        request: dict
            Dictionary with request parameters, like command.
        """

        try:  # send data to client
            for client in self.CLIENTS:
                client.write_message(data)
            logging.warn(f'Writing data {data.get("pack_id", "")} for {len(self.CLIENTS)} clients')
        except websocket.WebSocketClosedError as e:
            logging.warning("Send data: ", e)
            pass

    # ----------------------------------------------------------------------
    @classmethod
    def start_stream(self, **request):
        """If data available, send JSON object each 0.125 seconds."""
        #global STREAMING, CLIENTS

        if not self.STREAMING:
            #logging.warning('Calculating sample rate')
            # device.calculate_sample_rate()

            logging.warning('Start collecting')

            self.device.command(getattr(self.device, request['boardmode']))

            self.device.start_collect()
            self.device.reset_buffers()
            self.device.reset_input_buffer()
            self.device.pack_data(milliseconds=request['milliseconds'])
            self.STREAMING = True
            self.timed_stream()

    # ----------------------------------------------------------------------
    @classmethod
    def timed_stream(self):
        """"""
        #global STREAMING, CLIENTS, PACK_ID
        data = {
            'pack_id': self.PACK_ID,
            'buffer_size': self.device.eeg_buffer.qsize(),
            'pack_size': self.device.eeg_pack.qsize(),
            'sample_rate': self.device.sample_rate,
        }

        if data['pack_size']:
            data['data'] = [d.tolist() for d in self.device.eeg_pack.get()]
            data['sample_rate'] = len(data['data'][2]) / (self.device.pack_time * 1e-3)
            self.send_data(data)
            self.PACK_ID += 1
            self.PACK_ID = self.PACK_ID % 2 ** 10

        if self.CLIENTS:
            IOLoop.instance().add_timeout(timedelta(seconds=1 / (4 * self.device.sample_rate)), self.timed_stream)
        else:
            self.STREAMING = False
            self.device.stop_collect()
            logging.warning('Stop collecting')


